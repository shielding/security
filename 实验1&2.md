## 修改Unix可执行文件打印的字符串

* 在终端使用gcc得到可执行文件：

![](\可执行文件.png)

* 打开文件，修改字符串

![](\修改字符串.png)

* 输出修改的字符串

![](\cuc.png)

* Hopper Disassembler 查看main函数

![](\main函数.png)

* MachOView

![](\header.png)

* Disassembler自动为字符串命名‘aHelloCuc’，存储地址后三位为fa6，记住这个地址，之后肯定会用到。

![](\cstring.png)

* 文件头中关于cstring的部分

![](\cstring_header.png)

* 在文件末尾添加一段长字符串，将这一部分中的开始地址fa6修改成文件末尾的地址，并没有什么改变，输出还是hello cuc

![](\cstring_header1.png)

![](\修改后main.png)

* 通过MachOView再次观察main函数部分

![](\指令.png)

```bash
488D3D37 000000 //对应指令码
```

* 将字符串移到寄存器，无论如何都应该用到字符串的地址，但在这一句中fa6确实没有出现，猜测是使用了地址的差值。下一句指令的地址为0f6f，而恰好 37 = 0fa6 - 0f6f ！这下真相大白了。

* 重新选了一段长度为16056bits(3eb8)的英文，放在文件末尾。计算 20f3 - 0f6f = 1148，将

![](\change.png)

```bash
488D3D48 110000 //修改对应指令
```

* 成功输出想要的内容

![](\success.png)





